面向对象思想设计原则及常见设计模式

面向对象思想设计原则
设计模式
设计模式的分类
常见的设计模式
    简单工厂模式和工厂方法模式(接口)
    模版设计模式(抽象类)
    装饰设计模式(IO流)
    单例设计模式(多线程)
    适配器模式(GUI)

面向对象思想设计原则
在实际的开发中，我们要想更深入的了解面向对象思想，就必须熟悉前人总结过的面向对象的思想的设计原则
	单一职责原则
	开闭原则
	里氏替换原则
	依赖注入原则
	接口分离原则
	迪米特原则

单一职责原则
    其实就是开发人员经常说的 高内聚 低耦合
    也就是说 每个类应该只有一个职责 对外只能提供一种功能 而引起类变化的原因应该只有一个 在设计模式中 所有的设计模式都遵循这一原则

开闭原则
	核心思想是：一个对象对扩展开放，对修改关闭。
    其实开闭原则的意思就是：对类的改动是通过增加代码进行的，而不是修改现有代码。
    也就是说软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。

里氏替换原则
    核心思想 在任何父类出现的地方都可以用它的子类来替代
    其实就是说 同一个继承体系中的对象应该有共同的特为特征
	
依赖注入原则
    核心思想 要依赖于抽象 不要依赖于具体实现
    其实就是说 在应用程序中 所有的类如果使用或依赖于其他的类 则应该依赖这些其他类的抽象类 而不是这些其他类的具体类 为了实现这一原则 就要求我们在编程的时候针抽象类或者接口编程 而不是针对具体实现编程

接口分离原则
    核心思想 不应该强迫程序依赖它们不需要使用的方法
    其实就是说 一个接口不需要提供太多的行为 一个接口应该只提供一种对外的功能 不应该把所有的操作封装到一个接口中

迪米特原则
    核心思想 一个对象应当对其他对象尽可能少的了解
    其实就是说 降低各个对象之间的耦合 提高系统的可维护性 在模块之间应该只通过接口编程 而不理会模块的内部工作原理 它可以使各个模块耦合度降到最低 促进软件的复用

设计模式概述
    设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
    设计模式不是一种方法和技术，而是一种思想
    设计模式和具体的语言无关，学习设计模式就是要建立面向对象的思想，尽可能的面向接口编程，低耦合，高内聚，使设计的程序可复用
    学习设计模式能够促进对面向对象思想的理解，反之亦然。它们相辅相成

设计模式的几个要素
    名字必须有一个简单 有意义的名字
    问题描述在何时使用模式
    解决方案 描述设计的组成部分以及如何解决问题
    效果 描述模式的效果以及优缺点

设计模式的分类
    创建型模式 对象的创建
    结构型模式 对象的组成(结构)
    行为型模式 对象的行为

    创建型模式：简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式。(6个)
    结构型模式：外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)
    行为型模式：模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式。(10个)

简单工厂模式
简单工厂模式概述
又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例
优点
客户端不需要在负责对象的创建，从而明确了各个类的职责
缺点
这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护

动物抽象类：public abstract Animal { public abstract void eat(); }
具体狗类：public class Dog extends Animal {}
具体猫类：public class Cat extends Animal {}
开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。
public class AnimalFactory {
	private AnimalFactory(){}

	//public static Dog createDog() {return new Dog();}
	//public static Cat createCat() {return new Cat();}

	//改进
	public static Animal createAnimal(String animalName) {
		if(“dog”.equals(animalName)) {}
		else if(“cat”.equals(animale)) {

		}else {
			return null;
		}
	}
} 

工厂方法模式
工厂方法模式概述
工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。
优点
客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性
缺点
需要额外的编写代码，增加了工作量


动物抽象类：public abstract Animal { public abstract void eat(); }
工厂接口：public interface Factory {public abstract Animal createAnimal();}
具体狗类：public class Dog extends Animal {}
具体猫类：public class Cat extends Animal {}
开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。
狗工厂：public class DogFactory implements Factory {
	public Animal createAnimal() {…}
        }
猫工厂：public class CatFactory implements Factory {
	public Animal createAnimal() {…}
        }

单例设计模式概述
单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。
优点
在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
缺点
没有抽象层，因此扩展很难。
职责过重，在一定程序上违背了单一职责

模版设计模式概述
模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现
优点
使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求
缺点
如果算法骨架有修改的话，则需要修改抽象类

装饰设计模式概述
装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案
优点
使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能
缺点
正因为可以随意组合，所以就可能出现一些不合理的逻辑

手机添加新功能
1:继承版
2:装饰模式版
最后说说IO中的装饰模式应用


适配器设计模式概述
将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。
优点
让本来不适合使用的接口变得适合使用
缺点
一次只能适配一个类，使用有一定的局限性
