linux 介绍
linux 学习方法

linux 介绍
===================================================================
linux 发展史  开源软件简介  linux 应用领域

如何提问
	先要尝试自己解决 (帮助 文档 示例)  提问的智慧 (问题详尽 贴图)

linux 与 windows 的不同
    linux 严格区分大小写  linux 中所有内容以文件形式保存 包括硬件

linux 不靠扩展名区分文件类型
    压缩包 .gz .bz2 .tar.bz2 .tgz  二进制软件包 .rpm  网页文件 .html .php  脚本文件 .sh  配置文件夹 .conf

windows 下的程序不能直接在 linux 中安装和运行
    字符界面占用的系统资源更少  字符界面减少了出错 被攻击的可能性

linux 学习方法
===================================================================
学历低                  --- 可以通过自学来解决
外语不好 命令记不住     --- 可以通过查词等软件解决
非计算机专业 能否学得会 --- 多练习

捷径
跟一个人系统的 魔鬼式的学习一段时间 少看市面上一些免费的基础课视频 初学者不易直接看书
多练习


linux 系统下载

http://vault.centos.org/notonvault.html (可以查看所有镜像地址)

ftp://bay.uchicago.edu/centos-vault/
选择版本 (6.5 ...)
选择isos
选择 i386 (32位)  x86_64 (64位)


什么是别名
命令别名 == 人的小名
别名永久生效与删除别名
vi ~/.bashrc #写入环境变量配置文件
unalias 别名 #删除别名

常用快捷键
ctrl + c 强制终止当前命令
ctrl + l 清屏
ctrl + a 光标移到命令行首
ctrl + e 光标移到命令行尾
ctrl + u 从光标所在位置删除到行首
ctrl + z 把命令放入后台
ctrl + r 在历史命令中搜索

历史命令
history [选项] [历史命令保存文件]
-c 清空历史命令
-w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history

历史命令的调用
使用上下箭头调用以前的历史命令
使用 "!n" 重复执行第 n 条历史命令
使用 "!!" 重复执行上一条命令
使用 "!字串" 重复执行最后一条以该字串开头的命令

命令与文件补全
在 bash 中 命令与文件补全是非常方便与常用的功能 我们只要在输入命令或文件时 按 "Tab" 键就会自动进行补全

标准输入输出
设备   设备文件名   文件描述符 类型
键盘   /dev/stdin   0          标准输入
显示器 /dev/sdtout  1          标准输出
显示器 /dev/sdterr  2          标准错误输出

输出重定向
标准输出重定向 
命令 > 文件 以覆盖的方式 把命令的正确输出 输出到指定的文件或设备当中
命令 >> 文件 以追加的方式 把命令的正确输出 输出到指定的文件或设备当中
标准错误输出重定向
错误命令 2>文件 以覆盖的方式 把命令的错误输出 输出到指定的文件或设备当中
错误命令 2>>文件 以追加的方式 把命令的错误输出 输出到指定的文件或设备当中
正确输出和错误输出同时保存
命令 > 文件 2>&1 输出都保存到同一个文件当中
命令 >> 文件 2>&1 以追加的方式 把正确输出和错误输出都保存到同一个文件当中
命令 &> 文件 以覆盖的方式 把正确输出和错误输出都保存到同一个文件当中
命令 &>> 文件 以追加的方式 把正确输出和错误输出都保存到同一个文件当中
命令 >> 文件1 2>>文件2 把正确的输出追加到文件1中 把错误的输出追加到文件2 中

输入重定向
[root@localhost ~]# wc [选项][文件名]
-c 统计字节数
-w 统计单词数
-l 统计行数
命令 < 文件把文件作为命令的输入
命令 << 标识符
标识符把标识符之间内容作为命令的输入

多命令顺序执行
: 命令1:命令2 多个命令顺序执行 命令之间没有
&& 命令1&&命令2 逻辑与 当命令1正确执行 则命令2才会执行 当命令1执行不正确 则命令2不会执行
|| 命令1||命令2 逻辑或 当命令1执行不正确 则命令2才会执行 当命令1正确执行 则命令2不会执行
[root@localhost ~]# pwd; touch abc; ls; date
[root@localhost ~]# ls anaconda-ks.cfg && echo yes
[root@localhost ~]# ls anaconda-ks.cfg || echo no
[root@localhost ~]# 命令 && echo yes || echo no

管道符
[root@localhost ~]# 命令1 | 命令2 #命令1的正确输出作为命令2的操作对象
[root@localhost ~]# netstat -an | grep ESTABLISHED
[root@localhost ~]# netstat -an | grep ESTABLISHED | wc -l

通配符
? 匹配一个任意字符
* 匹配0个或任意多个任意字符
[] 匹配中括号中任意一个字符 例如: [abc] 代表一定匹配一个字符 或者是a 或者是b 或者说是c
[-] 匹配中括号中任意一个字符 -代表一个范围 例如 [a-z] 代表匹配一个小写字母
[^] 逻辑非 表示匹配不是中括号内的一个字符 例如 [^0-9] 代表匹配一个不是数字的字符

bash 中其他特殊符号
'' 单引号 在单引号中所有的特殊符号 如 "$" 和 "`" (反引号) 都没有特殊含义
"" 双引号 在双引号中特殊符号都没有特殊含义 但是 "$" "`" "\" 是例外 拥有 "调用变量的值" "引用命令" 和 "转义符" 的特殊含义
`  反引号 反引号括起来的内容是系统命令 在 bash 中会先执行它 和 $() 作用一样 不过推荐使用 $() 因为反引号非常容易看错
$() 和反引号作用一样 用来引用系统命令
# 用于调用变量的值 如需要调用变量 name 的值时 需要用 $name 的方式得到变量的值
\ 转义符号 跟在 \ 之后的特殊符号将推动特殊含义 变为普通字符 如\$将输出 "$" 符号 而不当做是变量引用