    正则表达式在程序语言中很常见

    有利于其他语言中正则表达式的学习

    正则表达式
    正则表达式是用于描述字符排列和匹配模式的一种语法规则 它主要用于字符串的模式分割 匹配 查找及替换操作

    通配符
    *   匹配任意内容
    ?   匹配任意一个内容
    []  匹配中括号中的一个字符

    基础正则表达式
    元字符  作用
    *       前一个字符匹配 0 次或任意多次
    .       匹配除了换行符外任意一个字符
    ^       匹配行首 例如 ^hello 会匹配以 hello 开头的行
    $       匹配行尾 例如 hello& 会匹配以 hello 结尾的行
    []      匹配中括号中指定的任意一个字符 只匹配一个字符 例如 [aoeiu] 匹配任意一个元音字母
    [^]     匹配除中括号的字符以外的任意一个字符 例如 [^0-9] 匹配任意一位非数字字符
    \       转义符 用于取消特殊符号的含义取消
    \{n\}   表示其前面的字符恰好出现 n 次
    \{n,\}  表示其前面的字符出现不小于 n 次
    \{n,m\} 表示其前面的字符至少出现n 次 最多出现 m 次 [a-z]\{6,8\} 匹配 6到 8 位的小写字母 

    正则表达式与通配符
    正则表达式用来在文件中匹配符合条件的字符串 正则是包含匹配 grep awk sed 等命令可以支持正则表达式
    通配符用来匹配符合条件的文件名 通配符是完全匹配 ls find cp 这些命令不支持正则表达式 所以只能使用 shell 自己的通配符来进行匹配了

    "*" 前一个字符匹配 0 次 或任意多次
    "a*" #匹配所有内容 包括空白行
    "aa*" #匹配至少包含有一个 a 的行
    "aaa*" 匹配最少包含两个连续a 的字符串
    "aaaaa*" #则会匹配最少包含四个个连续 a 的字符串

    "." 匹配除了换行符外任意一个字符
    "s..d" #"s..d" 会匹配在 s 和 d 这两个字母之间一定有两个字符的单词
    "s.*d" #匹配在 s 和 d 字母之间有任意字符
    ".*" #匹配所有内容

    "^" 匹配行首 "$"匹配行尾
    "^M" #匹配以大写 "M" 开头的行
    "n$" #匹配以小写 "n" 结尾的行驶
    "^$" #会匹配空白行

    "[]" 匹配中括号中指定的任意一个字符 只匹配一个字符
    "s[ao]id" #匹配s和 i 字母中 要不是a 要不是o
    "[0-9]" #匹配任意一个数字
    "^[a-z]" #匹配用小写字母开头的行

    "[^]" 匹配除中括号的字符以外的任意一个字符
    "^[^a-zA-Z]" #匹配不用小写字母开头的行
    "^[^a-zA-Z]" #匹配不用字母开头的行

    "\" 转义符
    "\.$" #匹配使用 "." 结尾的行

    [0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\} #匹配日期格式 YYYY-MM-DD
    [0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\} #匹配 IP 地址