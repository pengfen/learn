方法
数组

方法概述
假设有一个游戏程序，程序在运行过程中，要不断地发射炮弹(植物大战僵尸)。发射炮弹的动作需要编写100行的代码，在每次实现发射炮弹的地方都需要重复地编写这100行代码，这样程序会变得很臃肿，可读性也非常差。为了解决代码重复编写的问题，可以将发射炮弹的代码提取出来放在一个{}中，并为这段代码起个名字，这样在每次发射炮弹的地方通过这个名字来调用发射炮弹的代码就可以了。上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要发射炮弹时调用该方法即可

方法定义及格式
简单的说 方法就是完成特定功能的代码块
在很多语言里面都有函数的定义
函数在Java中被称为方法
格式
修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型 参数2 ...) {函数体; return 返回值;}

方法格式的解释说明
方法格式解释
修改符 比较多 后面会详细介绍 目前 public static
返回值类型 用于限定返回值的数据类型
方法名一个名称 为了方便我们调用方法
参数类型 限定调用方法时传入参数的数据类型
参数名 是一个变量 接收调用方法时传入的参数
方法体 完成功能的代码
return 结束方法以及返回方法指定类型的值
返回值 程序被return带回的结果 返回给调用者

方法案例
如何写一个方法呢 两个明确
返回值班类型 明确功能结果的数据类型
参数列表 明确有几个参数 以及参数的类型
按照格式和两个明确来完成如下功能
求两个数据之和的案例

1:写完案例后，不调用就执行，结果发现没有什么效果，引出方法一个很重要的特点：不调用不执行。
2:接着讲解方法是如何调用的?

有明确返回的方法调用
单独调用 没有意义
输出调用 有意义 但是不够好 因为我不一定非要把结果输出
赋值调用 推荐方式
讲解完毕该案例后 画图说明方法的调用过程

方法注意事项
方法不调用不执行
方法与方法是平级关系 不能嵌套定义
方法定义的时候不用在传递数据类型
如果方法有明确的返回值 一定要有 return 带回一个值

有明确返回值的方法练习
键盘录入两个数据 返回两个数中的较大值
键盘录入两个数据 比较两个数是否相等
键盘录入三个数据 返回三个数中的最大值

没有明确返回值的方法调用
没有明确返回值的函数调用
其实就是void类型方法的调用
只能单独调用

1:先通过在控制台输出一个4行5列的星形矩形来引入void类型的方法，然后讲解其调用


返回值为void 类型的方法练习
键盘录入行数和列数 输出对应的星形
键盘录入一个数据n(1 <= n <= 9) 输出的对应的 nn 乘法表


方法重载
方法重载概述
在同一个类中 允许存在一个以上的同名方法 只要它们的参数个数或者参数类型不同即可
方法重载特点
与返回值类型无关 只看方法名和参数列表
在调用时 虚拟机通过参数列表的不同来区分同名方法

方法重载案例
比较两个数据是否相等 参数类型分别为两个byte 类型 两个short类型 两个int类型 两个long类型 并在main方法中进行测试
方法递归在IO之前详细讲解


数组概述
需求 现在需要统计某公司员工的工资情况 例如计算平均工资 找到最高工资等 假设该公司有80名员工 用前面所学的知识 程序首先需要声明80个变量来分别记住每位员工的工资 然后在进行操作 这样做会显得很麻烦 为了解决这种问题 Java就提供了数组供我们使用
那么数组到底是什么呢 有什么特点呢 通过上面的分析 我们可以得到如下两句话
数组是存储多个变量(元素)的东西(容器)
这多个变量的数据类型要一致

数组概念
数组是存储同一种数据类型多个元素的集合 也可以看成是一个容器
数组既可以存储基本数据类型 也可以存储引用数据类型
数组的定义格式
格式1 数据类型[] 数组名
格式2 数据类型 数组名[]
注意 这两种定义做完了 数组中最没有元素值的 如何对数据的元素进行初始化呢

1:针对数组定义两种格式，推荐使用第一种格式。因为第一种的可读性更强。
  第二种可以早期的时候确实有很多人这样用。不过，现在这样用的人越来越少了。
2:作为Java的粉丝C#(Java的模仿者)就不再支持第二种语法格式了。越来越多的语言可能会抛弃第二种格式。

数组的初始化
数组初始化概述
Java中的数组必须先初始化 然后才能使用
所谓初始化 就是为数组中的数组元素分配内存空间 并为每个数组元素赋值
数组的初始化方式
动态初始化 初始化时只指定数组长度 由系统为数组分配初始值
静态初始化 初始化时指定每个数组元素的初始值 由系统决定数组长度

动态初始化 初始化时只指定数组长度 由系统为数组分配初始值
格式 数据类型[] 数据名 = new 数据类型[数组长度];
数组长度其实就是数组中元素的个数
举例
int[] arr = new int[3];
解释 定义了一个int类型的数组 这个数组中可以存放3个int类型的值

1:举例演示数值动态初始化案例，并测试数值数组名称，以及输出元素值。
2:如何获取元素值呢?这里再次引入数组中一个很重要的特点：就是如何取得数组中的元素呢?
	数组为每个元素都分配了编号，从0开始。获取的时候只要数组名配合编号即可。
	最大编号是长度-1。这个编号专业叫法称：索引。
3:通过数值名输出地址，数组元素输出0来引出Java中数据的内存分配

Java 中的内存分配
Java 程序在运行时 需要在内存中的分配空间 为了提高运算效率 就对空间进行了不同区域的划分 因为每一片区域都有特定的处理数据方式和内存管理方式
栈 存储局部变量
堆 存储new出来的东西
方法区(面向对象部分讲)
本地方法区(和系统相关)
寄存器(给CPU使用)

1：局部变量
	a:方法定义中或者方法声明上的所有变量
	b:使用完毕，立即消失

2：new出来的东西，实体，对象。
	new int[3];
	a:每一个实体都有首地址值
	b:每一个实体内的数据都有默认值
		byte,short,int,long 0
		float,double 0.0
		char ‘\u0000’
		boolean false
		引用类型：null
	c:使用完毕后，会被垃圾回收器空闲的时候回收。
其实讲解完堆和栈的区别，大家就能够理解刚才为什么输出的是地址和0了。

Java 中数据的内存图解
图解1 定义一个数组 输出数组名及元素 然后给数组中的元素赋值 再次输出数组名及元素
图解2 定义两个数组 分别输出数组名及元素 然后分别给数组中的元素赋值 分别再次输出数组名及元素
图解3 定义两个数组 先定义一个数组 赋值 输出 然后定义第二个数组的时候把第一个数组的地址赋值给第二个数组 然后给第二个数组赋值 再次输出两个数组的名及元素

静态初始化 初始化时指定每个数组元素的初始值 由系统决定数组长度
格式 数据类型[] 数组名 = new 数据类型[] {元素1,元素2,...}
举例
int[] arr = new int[]{1,2,3}
解释 定义了一个int类型的数组 这个数组中可以存放3个 int类型的值 并且值分别是1,2,3
其实这种写法还有一个简化的写法
int[] arr = {1,2,3};

1:内存图解和刚才有小的区别，画一个即可。
2:但是一定要注意不能同时进行动态初始化和静态初始化。
  什么意思呢，就是不能在给定数组长度的同时给出元素。

数组操作常见的两个小问题
数组索引越界
ArrayIndexOutOfBoundsException 访问到了数组中不存在的索引时发生
空指针异常
NullPointerException 数组引用没有指向实体 却在操作实体中的元素时

数据练习
数组遍历(依次输出数组中的每一个元素)
数组获取最值(获取数组中的最大值最小值)
数组元素逆序 (就是把元素对调)
数组查表法(根据键盘录入索引,查找对应星期)
数组元素查找(查找指定元素第一次在数组中出现的索引)
数组排序和二分查找(后面在数组高级部分讲解)

1:在遍历的时候，先数数，然后引出数组的一个属性：length。
  获取数值长度：数值名.length
  最后在把遍历的代码写成函数，然后再次调用。
  (改进版)还可以把数组的遍历做一个改进，通过字符串的拼接，让元素在一行上输出。

2:讲解最值的时候，我们可以先画图，然后讲解。
3:两种方式	
	for(int start=0,end=arr.length-1; start<=end; start++,end--) {
		int temp = arr[start];
		arr[start] = arr[end];
		arr[end] = temp;
	}

	for(int x=0; x<arr.length/2; x++) {
		int temp = arr[x];
		arr[x] = arr[arr.length-1-x];
		arr[arr.length-1-x] = temp;
	}
4:查找数值中的元素
	String[] strArray  = {“星期一”,”星期二”,”星期三”,…}
5:两种方式代码
	A:在判断里面返回索引，在循环外返回-1
	B:定义一个索引等于-1，如果查到了就修改索引，最终返回索引即可。

二维数组概述
我们传智播客的Java基础班每个班有很多个学生，所以，可以用数组来存储，而我们又同时有很多个Java基础班。这个也应该用一个数组来存储。如何来表示这样的数据呢?Java就提供了二维数组供我们使用。
由此可见：其实二维数组其实就是一个元素为一维数组的数组。


二维数组定义格式
格式1
数据类型[][] 变量名 = new 数据类型[m][n];
m表示这个二维数组有多少个一维数组
n表示每一个一维数组的元素个数
举例：
int[][] arr = new int[3][2];
定义了一个二维数组arr
这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]
每个一维数组有2个元素，可以通过arr[m][n]来获取
表示获取第m+1个一维数组的第n+1个元素
1:讲解格式，获取一个二维数组名称，一维数组名称，一个元素。(讲解)
2:针对格式1其实还可以
	int arr[][];
	int[] arr[];
	但是都不建议。
	
	这个时候提醒大家注意一个问题
	int[] x,y[];
	这种定义x是一个一维数组。
	y是一个二维数组。

3:画内存图讲解为什么是这个结果。(内存图)


格式2
数据类型[][] 变量名 = new 数据类型[m][];
m表示这个二维数组有多少个一维数组
这一次没有直接给出一维数组的元素个数，可以动态的给出。
举例：
int[][] arr = new int[3][];
arr[0] = new int[2];
arr[1] = new int[3]
arr[2] = new int[1];


格式3
数据类型[][] 变量名 = new 数据类型[][]{{元素…},{元素…},{元素…}};
简化版格式：
数据类型[][] 变量名 = {{元素…},{元素…},{元素…}};
举例：
int[][] arr =  {{1,2,3},{4,6},{6}};

二维数组练习
公司年销售额求和
某公司按照季度和月份统计的数据如下 单位(万元)
第一季度：22,66,44
第二季度：77,33,88
第三季度：25,45,65
第四季度：11,66,99
打印杨辉三角形(行数可以键盘录入)


1:杨辉三角形
1
1 1	
1 2 1
1 3 3 1
1 4 6 4 1 
1 5 10 10 5 1

分析：
	A:如果是n行，那么最后一行是n列。
	B:每一行的第一列和最后一列的元素是1。
	C:规律：
		每一行的第二列开始数据是：上一行的上一列+上一行的同一列
	D:把二维数组组成，然后遍历即可。
		遍历的时候，注意模仿九九乘法表的遍历。否则会有很多0。
		
		Scanner sc = new Scanner(System.in);
		
		System.out.println("请输入你准备打印的是一个多少行的杨辉三角：");
		int n = sc.nextInt();
		
		int[][] arr = new int[n][n];
		
		for(int x=0; x<n; x++) {
			arr[x][0] = 1;
			arr[x][x] = 1;
		}
		
		//第三行开始
		for(int x=2; x<n; x++) {
			//第二列开始,一定要记得减去最后一列
			for(int y=1; y<=x-1; y++) {
				arr[x][y] = arr[x-1][y-1]+arr[x-1][y];
			}
		}
		
		System.out.println("-----------------------");
		//输出的时候，千万要和九九乘法表的输出类似。
		for(int x=0; x<arr.length; x++) {
			for(int y=0; y<=x; y++) {
				System.out.print(arr[x][y]+"\t");
			}
			System.out.println();
		}



综合小练习
看程序写结果 并总结基本类型和引用类型参数的传递问题(题目在备注部分)
数据加密问题(题目在备注部分)

1:参数传递问题
		public static void main(String[] args)
		{
			int a = 10;
			int b = 20;
			System.out.println("a:"+a+",b:"+b);
			change(a,b);
			System.out.println("a:"+a+",b:"+b);

			int[] arr = {1,2,3,4,5};
			change(arr);
			System.out.println(arr[1]);
		}

		public static void change(int a,int b)  
		{
			System.out.println("a:"+a+",b:"+b);
			a = b;
			b = a + b;
			System.out.println("a:"+a+",b:"+b);
		}

		public static void change(int[] arr)
		{
			for(int x=0; x<arr.length; x++)
			{
				if(arr[x]%2==0)
				{
					arr[x]*=2;
				}
			}
		}
2:数据加密问题
	某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全，
	在传递过程中需要加密，加密规则如下：
		首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字，
		最后将第一位和最后一位数字交换。 请任意给定一个小于8位的整数，
		然后，把加密后的结果在控制台打印出来。 

=============================================================================
方法 (掌握)
    方法 就是完成特定功能的代码块
        注意 在很多语言里面有函数的定义 而在Java中 函数被称为方法
    格式 修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型 参数名2 ...) {
	        方法体语句;
	        return 返回值;
	    }

	    修饰符 目前就用 public static 后面再详细讲解其他修饰符
	    返回值类型 就是功能结果的数据类型
	    方法名 就是起了一个名字 方便我们调用该方法
	    参数类型 就是参数的数据类型
	    参数名 就是变量
	    参数分类
	        实参 实际参与运算的数据
	        形参 方法上定义的 用于接收实际参数的变量
	    方法体语句 就是完成功能的代码块
	    return 结束方法
	    返回值 就是功能的结果 由return带给调用者
    
    两个明确
        返回值类型 结果的数据类型
        参数列表 参数的个数及对应的数据类型

    方法调用
        有明确返回值的方法
            单独调用 没有意义
            输出调用 不是很好 因为我可能需要不结果进行进一步的操作 但是讲课一般我就用了
            赋值调用 推荐方案
        void 类型修饰的方法
            单独调用

    案例
        求和方案
        获取两个数中的较大值
        比较两个数据是否相同
        获取三个数中的最大值
        输出m行n列的星形
        输出nn乘法表

    方法的注意事项
        方法不调用不执行
        方法之间是平级关系 不能嵌套定义
        方法定义的时候 参数是用,隔开的
        方法在调用的时候 不用在传递数据类型
        如果方法有明确的返回值类型 就必须有return语句返回

    方法重载
        在同一个类中 方法名相同 参数列表不同 与返回值无关

        参数列表不同
            参数的个数不同
            参数的对应的数据类型不同

    方法重载案例
        不同的类型的多个同名方法的比较

数组(掌握)
    数组 存储同一种数据类型的多个元素的容器
    特点 每一个元素都有编号 从0开始 最大编号是长度-1
         编号的专业叫法 索引
    定义格式
        数据类型[] 数组名;
        数据类型 数组名[];

        推荐是用A方式 B方法就忘了吧  但是要能看懂

    数据的初始化
        动态初始化
            只给长度 系统给出默认值

            举例 int[] arr = new int[3];

        静态初始化
            给出值 系统决定长度

            举例 int[] arr = new int[]{1, 2, 3};
            简化版 int[] arr = {1, 2, 3}

        Java的内存分配
            栈 存储局部变量
            椎 存储所有new出来的
            方法区(面向对象部分详细讲解)
            本地方法区(系统相关)
            寄存器(CPU使用)

            注意
                局部变量 在方法定义中或者方法声明上定义的变量
                栈内存和堆内存的区别
                    栈 数据使用完毕 就消失
                    堆 每一个new出来的东西都有地址
                       每一个变量都有默认值
                           byte,shrort,int,long 0
                           float,double 0.0
                           char '\u0000'
                           boolean false
                           引用类型 null
                        数据使用完毕后 在垃圾回收器空闲的时候回收

        数组内存图
            一个数组
            二个数组
            三个数组(两个栈变量指向同一个堆内存)

        数组的常见操作
            遍历
                方式一
                    public static void printArray(int[] arr) {
                        for (int x = 0; x < arr.length; x ++) {
                            System.out.println(arr[x]);
                        }
                    }

                方式二
                    public static void printArray(int[] arr) {
                        System.out.print("[");
                        for (int x = 0; x < arr.length; x ++) {
                            if (x == arr.length - 1) {
                                System.out.println(arr[x] + "]");
                            } else {
                                System.out.println(arr[x] + ", ");
                            }
                        }
                    }

            最值
                最大值
                    public static int getMax(int[] arr) {
                        int max = arr[0];

                        for (int x = 1; x < arr.length; x ++) {
                            if (arr[x] < min) {
                                min = arr[x];
                            }
                        }

                        return min;
                    }

            逆序
                方式一
                    public static int reverse(int[] arr) {
                        for (int x = 0; x < arr.length / 2; x ++) {
                            int temp = arr[x];
                            arr[x] = arr[arr.length - 1 - x];
                            arr[arr.length - 1 - x] = temp;
                        }
                    }

                方式二
                    public static int reverse(int[] arr) {
                        for (int start = 0, end = arr.length - 1; start <= end; start ++, end --) {
                            int temp = arr[start];
                            arr[start] = arr[end];
                            arr[end] = temp;
                        }
                    }

            查表
                public satic String getString(String[] strArray, int index) {
                    return strArray[index];
                }

            基本查找
                方式一
	                public static int getIndex(int[] arr, int value) {
	                    for (int x = 0; x < arr.length; x ++) {
	                        if (arr[x] == value) {
	                            return x;
	                        }
	                    }

	                    return -1;
	                }

	            方式二
	                public static int getIndex(int[] arr, int value) {
	                    int index = -1;

	                    for (int x = 0; x < arr.length; x ++) {
	                        if (arr[x] == value) {
	                            index = x;
	                            break;
	                        }
	                    }

	                    return index;
	                }


====================================================================
二维数组 (理解)
    元素是一维数组的数组
    格式
        数据类型[][] 数组名 = new 数据类型[m][n];
        数据类型[][] 数组名 = new 数据类型[m][];
        数据类型[][] 数组名 = new 数据类型[][]{{...}, {...}, {...}};
        数据类型[][] 数组名 = new 数据类型{{...}, {...}, {...}};
    案例(掌握)
        二维数组的遍历
        二维数组的求和
        杨辉三角形

两个思考题(理解)
    Java中的参数传递问题
        Java中只有值传递

        基本类型 形式参数的改变不影响实际参数
        引用类型 形式参数的改变直接影响实际参数

    数据加密问题
        综合的小案例