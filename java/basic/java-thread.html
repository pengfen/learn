多线程概述
多线程实现方案
线程调度和线程控制
线程生命周期
线程同步
死锁
线程间通信
定时器的使用

多线程概述
多线程引入
把备注部分的代码通过画图解释一下调用流程 这个程序只有一个执行流程 所以这样的程序就是单线程程序
假如一个程序有多条执行流程 那么 该程序就是多线程程序
接下来我们来看看到底什么是多线程

public class Demo {
public static void main(String[] args) {
// 代码1
show();
// 代码2
}

public static void show() {
// 代码11
method1();
method2();
// 代码22
}

public static void method1() {
// 代码111...
}

public static void method2() {
// 代码222...
}
}

多线程概述
进程
正在运行的程序 是系统进行资源分配和调用的独立单位
每一个进程都有它自己的内存空间和系统资源
线程
是进程中的单个顺序控制流 是一条执行路径
一个进程如果只有一条执行路径 则称为单线程程序
一个进程如果有多条执行路径 则称为多线程程序
举例
扫雷游戏 迅雷下载等

要想说线程，首先必须得聊聊进程，因为线程是依赖于进程存在的。
2：那么，什么是进程呢?通过任务管理器我们就可以看到进程的存在。
	给出一个概念：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。
3：多进程有什么意义呢?
	单进程计算机只能做一件事情。而我们现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以我们常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。
	对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗?不是。
	因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。
	多进程的作用不是提高执行速度，而是提高CPU的使用率。

4：那么什么又是线程呢?
	在一个进程内部又可以执行多个任务，而这每一个任务我们就可以看成是一个线程。线程是程序中单个顺序的控制流，是程序使用CPU的基本单位。

5：多线程有什么意义呢？
	多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。
	而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。
	因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。
	
6：那么什么又是并发呢？
	大家注意两个词汇的区别：并行和并发。
	前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
	后者是物理上同时发生，指在某一个时间点同时运行多个程序。
	那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。
请
7：那么，我们来举例说说什么是进程，什么是线程。
	扫雷游戏，迅雷下载等。

Java 程序运行原理
java命令会启动java虚拟机 启动JVM 等于启动了一个应用程序 也就是启动了一个进程 该进程会自动启动一个 "主线程" 然后主线程去调用某个类的main方法 所以  main方法运行在主线程中 在此之前的所有程序都是单线程的
思考 jvm虚拟机的启动是单线程的还是多线程的

1：JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。

多线程的实现方案
通过查看API来学习多线程程序的实现 参考Thread类
继承Thread类
步骤及代码演示
几个小问题
为什么要重写run()方法
启动线程使用的是那个方法
线程能不能多次启动
run()和start()方法的区别

如何获取和设置线程名称
Thread类的基本获取和设置方法
public final String getName()
public final void setName(String name)
其实通过构造方法也可以给线程起名字
思考
如何获取main方法所在的线程名称呢
public static Thread currentThread() 这样就可以获取任意方法所在的线程名称

线程调度
假如我们的计算机只有一个CPU 那么CPU在某一个时刻只能执行一条指令 线程只有得到CPU时间片 也就是使用权 才可以执行指令 那么Java是如何对线程进行调用的呢
线程有两种调度模型
分时调度模型 所有线程轮流使用CPU的使用权 平均分配每个线程占用CPU的时间片
抢占式调度模型 优先让优先级高的线程使用CPU 如果线程的优先级相同 那么会随机选择一个 优先级高的线程获取的CPU时间片相对多一些
Java使用的是抢占式调度模型
演示如何设置和获取线程优先级
public final int getPriority()
public final void setPriority(int newPriority)

线程控制
我们已经知道了线程的调度 接下来我们就可以使用如下方法对象线程进行控制
线程休眠 public static void sleep(long millis)
线程加入 public final void join()
线程礼让 public static ovid yield()
后台线程 public final void setDaemon(boolean on)
中断线程 public final void stop()  public void interrupt()

多线程的实现方案
实现Runnable接口
如何获取线程名称
如何给线程设置名称
实现接口方式的好处
可以避免由于Java单继承带来的局限性
适合多个相同程序的代码去处理同一个资源的情况 把线程同程序的代码 数据有效分离 较好的体现了面向对象的设计思想

多线程程序练习
需求
某电影院目前正在上映贺岁大片 共有100线票 而它有3个售票 请设计一个程序模拟该电影院售票
两种方式实现
继承Thread类
实现Runnable接口

关于电影院卖票程序的思考
我们前面讲解过电影院售票程序 从表面上看不出什么问题 但是在真实生活中 售票时网络是不能实时传输的 总是存在延迟的情况 所以 在出售一张票以后 需要一点时间的延迟
改实现接口方式的卖票程序
每次卖票延迟100毫秒

改进后的电影院售票出现问题
问题 
相同的票出现多次 CPU的一次操作必须是原子性的
还出现了负数的票 随机性和延迟导致的
注意 线程安全问题在理想状态下 不容易出现 但一旦出现对软件的影响是非常大的确

解决线程安全问题的基本思想
首先想为什么出现问题 (也是我们判断是否有问题的标准)
是否是多线程环境
是否有共享数据
是否有多条语句操作共享数据
如何解决多线程安全问题呢
基本思想 让程序没有安全问题的环境
怎么实现呢
把多个语句操作共享数据的代码给锁起来 让任意时刻只能有一个线程执行即可

解决线程安全问题实现
同步代码块
格式 synchronized(对象){需要同步的代码}
同步可以解决安全问题的根本原因就在那个对象上 该对象如同锁的功能
同步代码块的对象可以是哪些呢

经典举例：
	医院挂号看病
	火车上的卫生间

同步的特点
同步的前提
多个线程
多个线程使用的是同一个锁对象
同步的好处 同步的出现解决了多线程的安全问题
同步的弊端 当线程相当多时 因为每个线程都会去判断同步上的锁 这是很耗费资源的 无形中会降低程序的运行效率

1：讲解完毕同步特点后，把刚才的代码改进下引出同步方法。

解决线程安全问题实现
同步方法 就是把同步关键字加到方法上
同步方法的锁对象是什么呢
如果是静态方法 同步方法的锁对象又是什么呢
那么 我们到底使用谁
如果锁对象是this 就可以考虑使用同步方法
否则能使用同步代码块的尽量使用同步代码块

回顾前面的线程安全问题(看看源码)
	StringBuffer/StringBuilder
	Vector
	Hashtable
	以及Collections中的让集合同步功能。

JDK5中Lock锁的使用
虽然我们可以理解同步代码块和同步方法的锁对象问题 但是我们并没有直接看到在哪里加上了锁 在哪里释放了锁 为了更清晰的表达如何加锁和释放锁 JDK5以后提供了一个新的锁对象Lock
Lock
void lock()
void unlock()
ReentrantLock

死锁问题
同步弊端
效率低
如果出现了同步嵌套 就容易产生死锁问题
死锁问题及其代码
是指两个或者两个以上的线程在执行的过程中 因争夺资源产生的一种互相等待现象
同步代码块的嵌套案例

线程间通信
针对同一个资源的操作有不同种类的线程
举例 卖票有进的 也有出的
通过设置线程(生产者)和获取线程(消费者)针对同一个学生对象进行操作

线程间通信的代码改进
A 通过等待唤醒机制实现数据依次出现
B 把同步代码块改进为同不方法实现

线程组
Java中使用ThreadGroup来表示线程组 它可以对一批线程进行分类管理 Java 允许程序直接对线程组进行控制
默认情况下 所有的线程都属于主线程组
public final ThreadGroup getTheadGroup()
我们也可以给线程设置分组
Thread(TheadGroup group, Runnable target, String name)

线程池
程序启动一个新线程成本是比较高的 因为它涉及到要与操作系统进行交互 而使用线程池可以很好的提高性能
尤其是当程序中要创建大量生存期很短的线程时 更应该考虑使用线程池
线程池里的每一个线程代码结束后 并不会死亡 而是再次回到线程池中成为空闲状态 等待下一个对象来使用
在JDK5之前 我们必须手动实现自己的线程池 从JDK5开始 Java内置支持线程池

JDK5新增了一个Executors工厂类来产生线程池 有如下几个方法
public static ExecutorService newCachedThreadPool()
public static ExceutorService newFixedThreadPool(int nThreads)
public static ExceutorService newSingle ThreadExecutor()
这些方法的返回值是ExecutorService对象 该对象表示一个线程池 可以执行Runnable对象或者Callable对象代表的线程 它提供了如下方法
Future<?> submit(Runnable task)
<T> Future<T> submit(Callable<T> task)
案例演示
创建线程池对象
创建Runnable实例
提交Runnable实例
关闭线程池

public static ExecutorService newCachedThreadPool()
	创建一个具有缓存功能的线程池
	缓存：百度浏览过的信息再次访问
public static ExecutorService newFixedThreadPool(int nThreads)
	创建一个可重用的，具有固定线程数的线程池
public static ExecutorService newSingleThreadExecutor()
	创建一个只有单线程的线程池，相当于上个方法的参数是1	

多线程程序实现方案
实现Callable接口
步骤和刚才演示线程池执行Runnable对象的差不多
但是还可以更好玩一些 求和案例演示
好处 可以有返回值 可以抛出异常
弊端 代码比较复杂，所以一般不用

匿名内部类方式使用多线程
匿名内部类方式使用多线程
new Thread(){代码 ...}.start();
New Thread(new Runnable(){代码 ... }).start();

new Thread() {
public void run() {
for (int x = 0; x < 100; x++) {
System.out.println(getName() + "---" + x);
}
};
}.start();

new Thread(new Runnable() {
@Override
public void run() {
for (int x = 0; x < 100; x++) {
System.out.println(Thread.currentThread().getName() + "---"
+ x);
}
}
}).start();

定时器
定时器是一个应用十分广泛的线程工具 可用于调度多个定时任务以后台线程的方式执行 在Java中 可以通过Timer和TimerTask类来实现定义调度的功能
Timer
public Timer()
public void schedule(TimerTask task, long delay)
public void schedule(TimerTask task, long delay, long period)
TimerTask
public abstract void run()
public boolean cancel()
开发中 Quartz是一个完全由java编写的开源调度框架

1：演示3秒后执行某个动作，
2：演示3秒后执行某个动作，然后每隔2秒执行某个动作
3：可以把任务结束掉

多线程面试题
多线程有几中实现方案 分别是哪几种
同步有几中方式 分别是什么
启动一个线程是run() 还是start() 它们的区别
sleep()和wait()方法的区别
为什么wait() notify() notifyAll() 等方法都定义在Object类中
线程的生命周期图

wait(),notify(),notifyAll(),用来操作线程为什么定义在了Object类中？
1，这些方法存在与同步中。
2，使用这些方法时必须要标识所属的同步的锁。
3，锁可以是任意对象，所以任意对象调用的方法一定定义Object类中。

设计模式
设计模式概述 什么是设计模式
设计模式分类
创建型模式
行为型模式
结构型模式

单例设计模式
单例设计思想 保证类在内存中只有一个对象
如何实现类在内存中只有一个对象呢
构造私有
本身提供一个对象
通过公共的方法让外界访问

单例设计模式分类
饿汉式(开发)
懒汉式(面试)
线程安全问题
懒加载思想(延迟加载)

Runtime 类的概述和使用
Runtime 类的概述
每个Java应用程序都有一个Runtime类实例 使用程序能够与其运行的环境相连接 可以通过getRuntime方法获取当前运行时
应用程序不能创建自己的Runtime类实例
Runtime类使用
public Process exec(String command)

======================================================
1:多线程(理解)
	(1)多线程：一个应用程序有多条执行路径
		进程：正在执行的应用程序
		线程：进程的执行单元，执行路径
		单线程：一个应用程序只有一条执行路径
		多线程：一个应用程序有多条执行路径
		
		多进程的意义?
			提高CPU的使用率
		多线程的意义?
			提高应用程序的使用率
	(2)Java程序的运行原理及JVM的启动是多线程的吗?
		A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。
		B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。
	(3)多线程的实现方案(自己补齐步骤及代码	掌握)
		A:继承Thread类
		B:实现Runnable接口
	(4)线程的调度和优先级问题
		A:线程的调度
			a:分时调度
			b:抢占式调度 (Java采用的是该调度方式)
		B:获取和设置线程优先级
			a:默认是5
			b:范围是1-10
	(5)线程的控制(常见方法)
		A:休眠线程
		B:加入线程
		C:礼让线程
		D:后台线程
		E:终止线程(掌握)
	(6)线程的生命周期(参照	线程生命周期图解.bmp)
		A:新建
		B:就绪
		C:运行
		D:阻塞
		E:死亡
	(7)电影院卖票程序的实现
		A:继承Thread类
		B:实现Runnable接口
	(8)电影院卖票程序出问题
		A:为了更符合真实的场景，加入了休眠100毫秒。
		B:卖票问题
			a:同票多次
			b:负数票
	(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)
		A:是否有多线程环境
		B:是否有共享数据
		C:是否有多条语句操作共享数据
	(10)同步解决线程安全问题
		A:同步代码块
			synchronized(对象) {
				需要被同步的代码;
			}
			
			这里的锁对象可以是任意对象。
			
		B:同步方法
			把同步加在方法上。
			
			这里的锁对象是this
			
		C:静态同步方法
			把同步加在方法上。
			
			这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)
	(11)回顾以前的线程安全的类
		A:StringBuffer
		B:Vector
		C:Hashtable
		D:如何把一个线程不安全的集合类变成一个线程安全的集合类
			用Collections工具类的方法即可。